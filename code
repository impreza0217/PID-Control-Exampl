import time
import matplotlib.pyplot as plt  # 引入 matplotlib 用於繪圖

# PID 控制器類
class PID:
    def __init__(self, Kp, Ki, Kd):
        # 初始化 PID 參數
        self.Kp = Kp    # 比例增益
        self.Ki = Ki    # 積分增益
        self.Kd = Kd    # 微分增益
        self.previous_error = 0  # 上次誤差
        self.integral = 0  # 積分項的累積誤差

    def compute(self, setpoint, measured_value):
        # 計算 PID 控制輸出
        error = setpoint - measured_value  # 計算誤差
        self.integral += error  # 累積誤差（積分項）
        derivative = error - self.previous_error  # 計算誤差變化率（微分項）

        # PID 控制公式
        output = self.Kp * error + self.Ki * self.integral + self.Kd * derivative

        # 更新前次誤差
        self.previous_error = error

        return output

# 模擬的系統
class Process:
    def __init__(self):
        self.value = 0  # 初始化系統輸出

    def update(self, control_signal):
        # 模擬系統響應（簡化為控制信號直接影響系統狀態）
        self.value += control_signal
        # 限制系統輸出的最大值和最小值
        self.value = max(0, min(self.value, 100))

# 主程式
if __name__ == "__main__":
    setpoint = 50  # 設定目標值
    pid = PID(Kp=1.2, Ki=1.0, Kd=0.01)  # 初始化 PID 控制器
    process = Process()  # 初始化系統
    time_step = 0.1  # 控制周期（秒）

    # 用來儲存數據
    measured_values = []  # 系統實際輸出
    control_signals = []  # PID 控制信號
    errors = []           # 誤差
    time_steps = []       # 時間步數

    # 模擬運行
    for t in range(100):
        measured_value = process.value  # 取得當前系統輸出
        error = setpoint - measured_value  # 計算誤差
        control_signal = pid.compute(setpoint, measured_value)  # 計算控制信號
        process.update(control_signal)  # 更新系統狀態

        # 記錄數據
        measured_values.append(measured_value)
        control_signals.append(control_signal)
        errors.append(error)
        time_steps.append(t * time_step)  # 這裡 t * time_step 計算每個時間步的時間

        time.sleep(time_step)  # 延遲一段時間模擬實時控制

    # 用 matplotlib 繪製模擬圖
    plt.figure(figsize=(12, 8))

    # 第 1 張圖：系統輸出與目標值的比較
    plt.subplot(3, 1, 1)
    plt.plot(time_steps, measured_values, label="Measured Value (System Output)", color='b')
    plt.axhline(setpoint, color='r', linestyle='--', label="Setpoint")  # 目標值的虛線
    plt.xlabel('Time (s)')
    plt.ylabel('System Output')
    plt.legend()
    plt.title('System Output vs Setpoint')

    # 第 2 張圖：控制信號隨時間變化
    plt.subplot(3, 1, 2)
    plt.plot(time_steps, control_signals, label="Control Signal", color='g')
    plt.xlabel('Time (s)')
    plt.ylabel('Control Signal')
    plt.legend()
    plt.title('Control Signal vs Time')

    # 第 3 張圖：誤差隨時間變化
    plt.subplot(3, 1, 3)
    plt.plot(time_steps, errors, label="Error (Setpoint - Measured)", color='r')
    plt.axhline(0, color='black', linestyle='--', label="Zero Error")  # 顯示誤差為零的線
    plt.xlabel('Time (s)')
    plt.ylabel('Error')
    plt.legend()
    plt.title('Error vs Time')

    # 顯示所有圖形
    plt.tight_layout()  # 自動調整布局避免重疊
    plt.show()
